"""Prompt templates and structured response models for Who Gets You?."""

from __future__ import annotations

from typing import Iterable, List

from pydantic import BaseModel, Field
from typing_extensions import Literal

from models import SUPPORTED_LANGUAGES

GAME_RULES_SUMMARY = """
Who Gets You? is a multiplayer party game focused on storytelling and empathy.
Game setup:
- Host names the room, chooses gameplay mode (Simple or Bluffing), theme mode (Static/Dynamic), and level mode (Static/Dynamic).
- Themes describe life domains (e.g., childhood, travel, work). Levels describe depth: Narrow (surface level), Medium (thoughtful), Deep (vulnerable/introspective).

Turn structure:
1. The Storyteller is selected. If modes are dynamic, they pick the theme/level for the round.
2. The Storyteller receives a single conversation prompt generated by the AI and may regenerate until it feels relevant and emotionally safe.
3. The Storyteller responds honestly. In Bluffing mode they also provide one plausible but false "trap" answer meant to mislead their friends.
4. The AI turns the real answer (plus trap answer when applicable) into multiple-choice options along with believable distractors.
5. Listeners guess. Scoring happens per gameplay rules, then the next round begins.

Scoring overview (per listener):
- Simple gameplay:
  * Narrow: listener +1 for a correct guess. If only some listeners guess correctly Storyteller +1. If all listeners guess correctly Storyteller +2. Medium/Deep multiply listener & storyteller points by 2x/3x.
- Bluffing gameplay:
  * Narrow: listener +1 for correct guess. If some (not all) listeners guess correctly Storyteller +1. If exactly one listener guesses correctly, both that listener and Storyteller +3. If everyone guesses correctly each listener +2 and Storyteller 0. Medium/Deep multiply totals by 2x/3x.

Tone guidelines:
- Questions should celebrate vulnerability without prying. Avoid cliches, yes/no formats, or anything unsafe/triggering.
- Answers should be first-person, conversational, and feel authentic. Trap answers must be believable but clearly not the exact truth.
- Multiple-choice options should feel like they were actually written by the same person.
"""

LEVEL_DESCRIPTIONS = {
    "narrow": "Light, ice-breaker territory. Situational facts or quick reflections that anyone can answer without over-sharing.",
    "medium": "Thoughtful but comfortable. Encourages short stories or opinions that reveal personality and values.",
    "deep": "Introspective and emotionally aware. Invites vulnerability, formative memories, or personal growth moments while staying respectful.",
}

SYSTEM_PROMPT = f"""You are the narrative director for the party game "Who Gets You?". \
Use the rules below to keep questions, answers, and multiple-choice options safe, inclusive, and emotionally intelligent.
{GAME_RULES_SUMMARY.strip()}
Always return JSON that matches the provided schema for the current task."""


def _language_name(code: str) -> str:
    return SUPPORTED_LANGUAGES.get((code or "").lower(), code or "English")


def _render_previous_questions(previous_questions: Iterable[str]) -> str:
    cleaned = [q.strip() for q in previous_questions or [] if q and q.strip()]
    if not cleaned:
        return "None provided. Feel free to explore any original angle."
    bullets = "\n".join(f"- {q}" for q in cleaned)
    return f"Previously used questions:\n{bullets}"


def build_question_prompt(theme: str, level: str, previous_questions: Iterable[str], language: str) -> str:
    language_name = _language_name(language)
    return (
        f"Generate a single question for the theme '{theme}'.\n"
        f"Depth: {level.title()} — {LEVEL_DESCRIPTIONS.get(level, 'Keep it warm and sincere')}.\n"
        f"{_render_previous_questions(previous_questions)}\n"
        f"Write the final question entirely in {language_name}.\n"
        "Requirements:\n"
        "- Make it open-ended and non-repetitive.\n"
        "- Keep it respectful and supportive; avoid cliches, yes/no questions, or anything that might trigger trauma.\n"
        "- Output JSON with 'question' and 'reason' explaining why it fits the round."
    )


def build_answer_prompt(question: str, storyteller_name: str, gameplay_mode: str, language: str) -> str:
    language_name = _language_name(language)
    honesty_hint = (
        "Simple mode: answer truthfully while sounding conversational and specific."
        if gameplay_mode == "simple"
        else "Bluffing mode: provide the Storyteller's honest answer that still feels vulnerable."
    )
    return (
        f"The storyteller is {storyteller_name}. Help them respond to:\n"
        f"Question: {question}\n"
        f"{honesty_hint}\n"
        f"Return the answer entirely in {language_name}.\n"
        "Return JSON with 'answer' (first-person) and 'rationale' briefly explaining the emotional note you aimed for."
    )


def build_trap_prompt(question: str, true_answer: str, storyteller_name: str, language: str) -> str:
    language_name = _language_name(language)
    return (
        f"The storyteller {storyteller_name} already has the true answer below.\n"
        f"Question: {question}\n"
        f"True answer: {true_answer}\n"
        "Invent a believable but wrong answer (the 'trap') that close friends might mistake for the truth. "
        "Keep tone consistent with the storyteller's voice and avoid contradicting obvious facts from the true answer.\n"
        f"Write the trap entirely in {language_name}.\n"
        "Return JSON with 'answer' and 'rationale'."
    )


def build_multiple_choice_prompt(
    question: str,
    true_answer: str,
    trap_answer: str | None,
    gameplay_mode: str,
    level: str,
    num_distractors: int,
    language: str,
) -> str:
    language_name = _language_name(language)
    trap_line = (
        f"The storyteller also provided a trap answer for Bluffing mode:\nTrap: {trap_answer}\n"
        if trap_answer
        else "Gameplay mode is Simple so there is no trap answer.\n"
    )
    return (
        f"Create multiple-choice options for listeners guessing {question}\n"
        f"Depth guidance: {level.title()} — {LEVEL_DESCRIPTIONS.get(level, 'balanced tone')}.\n"
        f"True answer: {true_answer}\n"
        f"{trap_line}"
        f"Write every option and rationale entirely in {language_name}.\n"
        f"Include exactly {num_distractors} additional distractors that sound natural.\n"
        "Label answers sequentially starting at A. Output JSON with:\n"
        "- question (string)\n"
        "- options (list of objects with 'label', 'text', 'kind' of 'true'|'trap'|'distractor', and optional 'hint')\n"
        "- rationale: quick reminder for the host about the tone."
    )


class QuestionLLMResponse(BaseModel):
    question: str = Field(..., description="The final question text delivered to the storyteller.")
    reason: str = Field(..., description="Short explanation of why the question fits the theme and level.")


class AnswerSuggestionResponse(BaseModel):
    answer: str = Field(..., description="Single first-person answer.")
    rationale: str = Field(..., description="Design note about the emotional tone or storytelling hook.")


class MultipleChoiceOption(BaseModel):
    label: str = Field(..., description="Single-letter identifier such as A, B, C.")
    text: str = Field(..., description="What the listeners read.")
    kind: Literal["true", "trap", "distractor"] = Field(..., description="How this option should be treated in scoring.")
    hint: str | None = Field(None, description="Optional meta note for the host about why the option works.")


class MultipleChoiceResponse(BaseModel):
    question: str
    rationale: str
    options: List[MultipleChoiceOption]
